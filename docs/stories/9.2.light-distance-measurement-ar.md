# Story 9.2: Light Distance Measurement with ARKit

## Status

Approved

## Story

**As a** grower setting up lights,
**I want** to measure the distance from my light to the plant canopy using my phone's camera and AR,
**so that** I can ensure optimal light placement without guessing or using manual measuring tools.

## Acceptance Criteria

1. Users can launch AR measurement tool from Plant Detail â†’ Light tab
2. App uses ARKit to detect surfaces and measure distances
3. User points camera at light source and taps to mark it
4. User points camera at plant canopy and taps to mark it
5. App displays distance in inches and centimeters with real-time updates
6. AR overlay shows measurement line between light and canopy with animated markers
7. App provides instant feedback: "Too close", "Optimal", "Too far" based on light type and plant stage
8. Measurement is saved to plant profile
9. Measurement logging creates diary event with distance and light type
10. App works in both well-lit and low-light environments (uses LiDAR on supported devices)
11. Tutorial overlay guides first-time users through measurement process
12. Fallback: Manual distance entry if ARKit unavailable or user prefers

## Tasks / Subtasks

- [ ] Implement ARKit session management (AC: 1, 2, 10)
  - [ ] Create `LightDistanceARView` using RealityKit/ARKit
  - [ ] Configure AR session with world tracking
  - [ ] Detect horizontal and vertical planes
  - [ ] Use LiDAR when available for better accuracy
  - [ ] Handle camera permissions
- [ ] Build AR measurement UI (AC: 3, 4, 5, 6)
  - [ ] Camera view with AR overlay
  - [ ] Tap gesture to place markers
  - [ ] First tap: light source marker (yellow)
  - [ ] Second tap: canopy marker (green)
  - [ ] Real-time distance calculation
  - [ ] Animated measurement line with label
  - [ ] Display distance in both inches and cm
- [ ] Implement distance calculation (AC: 5)
  - [ ] Calculate 3D distance between two AR points
  - [ ] Convert to inches and centimeters
  - [ ] Update in real-time as user moves
- [ ] Build recommendation engine (AC: 7)
  - [ ] Define optimal distance ranges per light type and stage
  - [ ] LED: Seedling 24-30", Veg 18-24", Flower 12-18"
  - [ ] HPS/MH: Seedling 30-36", Veg 24-30", Flower 18-24"
  - [ ] CFL: Seedling 6-12", Veg 6-12", Flower 6-12"
  - [ ] Show color-coded feedback (green/yellow/red)
  - [ ] Display recommendation text
- [ ] Persist measurement data (AC: 8, 9)
  - [ ] Save distance to Plant.lightDistance field
  - [ ] Create diary event with light measurement data
  - [ ] Store light type, distance, timestamp
- [ ] Build tutorial overlay (AC: 11)
  - [ ] First-time user: show step-by-step guide
  - [ ] Arrows and text annotations
  - [ ] "Tap light source" â†’ "Tap canopy" â†’ "Done"
  - [ ] Skip option
  - [ ] Persist tutorial completion in UserDefaults
- [ ] Handle edge cases and errors (AC: 10, 12)
  - [ ] ARKit unavailable (old device) â†’ manual entry
  - [ ] Poor tracking quality â†’ show warning
  - [ ] Low light (no LiDAR) â†’ show flashlight suggestion
  - [ ] Manual entry fallback UI

## Dev Notes

### Architecture Context

This story leverages Apple's ARKit to solve a common grower problem: determining optimal light distance. Traditional methods (rulers, measuring tape) are cumbersome in grow spaces.

**Why AR for Light Distance:**
- Hands-free measurement
- Real-time feedback
- Visual confirmation
- Educational (shows optimal vs actual)

### Source Tree

```
GroBroPackage/
  Sources/
    GroBroDomain/
      Models/
        LightMeasurement.swift           # Measurement data model
      Services/
        LightRecommendationEngine.swift  # Optimal distance logic
    GroBroFeature/
      PlantDetail/
        Light/
          LightDistanceARView.swift      # AR measurement UI
          LightDistanceTutorial.swift    # Tutorial overlay
          ManualDistanceEntryView.swift  # Fallback manual entry
```

### Key Implementation Notes

1. **ARKit Session Setup:**
   ```swift
   import ARKit
   import RealityKit

   struct LightDistanceARView: View {
       @State private var arSession = ARWorldTrackingConfiguration()
       @State private var lightMarker: simd_float3?
       @State private var canopyMarker: simd_float3?
       @State private var distance: Double?

       var body: some View {
           ZStack {
               ARViewContainer(
                   session: arSession,
                   lightMarker: $lightMarker,
                   canopyMarker: $canopyMarker
               )

               // AR Overlay UI
               VStack {
                   if let dist = distance {
                       DistanceLabel(inches: dist)
                           .padding()
                           .background(.ultraThinMaterial)
                           .cornerRadius(12)
                   }

                   Spacer()

                   InstructionText(
                       step: lightMarker == nil ? "Tap light source" : "Tap plant canopy"
                   )
                   .padding()
               }
           }
           .onAppear {
               startARSession()
           }
       }

       func startARSession() {
           arSession.planeDetection = [.horizontal, .vertical]
           if ARWorldTrackingConfiguration.supportsSceneReconstruction(.mesh) {
               arSession.sceneReconstruction = .mesh
           }
           // Start session
       }
   }
   ```

2. **ARViewContainer with RealityKit:**
   ```swift
   struct ARViewContainer: UIViewRepresentable {
       let session: ARWorldTrackingConfiguration
       @Binding var lightMarker: simd_float3?
       @Binding var canopyMarker: simd_float3?

       func makeUIView(context: Context) -> ARView {
           let arView = ARView(frame: .zero)
           arView.session.run(session)

           // Add tap gesture
           let tapGesture = UITapGestureRecognizer(
               target: context.coordinator,
               action: #selector(Coordinator.handleTap(_:))
           )
           arView.addGestureRecognizer(tapGesture)

           context.coordinator.arView = arView
           return arView
       }

       func makeCoordinator() -> Coordinator {
           Coordinator(lightMarker: $lightMarker, canopyMarker: $canopyMarker)
       }

       class Coordinator: NSObject {
           @Binding var lightMarker: simd_float3?
           @Binding var canopyMarker: simd_float3?
           var arView: ARView?

           init(lightMarker: Binding<simd_float3?>, canopyMarker: Binding<simd_float3?>) {
               _lightMarker = lightMarker
               _canopyMarker = canopyMarker
           }

           @objc func handleTap(_ gesture: UITapGestureRecognizer) {
               guard let arView = arView else { return }

               let location = gesture.location(in: arView)
               let results = arView.raycast(from: location, allowing: .estimatedPlane, alignment: .any)

               guard let result = results.first else { return }

               let position = simd_make_float3(result.worldTransform.columns.3)

               if lightMarker == nil {
                   // First tap: mark light
                   lightMarker = position
                   addMarker(at: position, color: .yellow, in: arView)
               } else if canopyMarker == nil {
                   // Second tap: mark canopy
                   canopyMarker = position
                   addMarker(at: position, color: .green, in: arView)
                   drawMeasurementLine(from: lightMarker!, to: position, in: arView)
               }
           }

           func addMarker(at position: simd_float3, color: UIColor, in arView: ARView) {
               let sphere = ModelEntity(
                   mesh: .generateSphere(radius: 0.02),
                   materials: [SimpleMaterial(color: color, isMetallic: false)]
               )
               let anchor = AnchorEntity(world: position)
               anchor.addChild(sphere)
               arView.scene.addAnchor(anchor)
           }

           func drawMeasurementLine(from start: simd_float3, to end: simd_float3, in arView: ARView) {
               // Draw line between markers
               let midpoint = (start + end) / 2
               let distance = simd_distance(start, end)

               // Add line entity
               // Add text label with distance
           }
       }
   }
   ```

3. **Distance Calculation:**
   ```swift
   func calculateDistance(from: simd_float3, to: simd_float3) -> (meters: Double, inches: Double, cm: Double) {
       let meters = Double(simd_distance(from, to))
       let inches = meters * 39.3701
       let cm = meters * 100
       return (meters, inches, cm)
   }
   ```

4. **Recommendation Engine:**
   ```swift
   struct LightRecommendation {
       enum Status {
           case tooClose, optimal, tooFar
       }

       static func evaluate(
           distance: Double, // inches
           lightType: LightType,
           stage: GrowthStage
       ) -> (status: Status, message: String) {
           let optimal = optimalRange(for: lightType, stage: stage)

           if distance < optimal.lowerBound {
               let diff = optimal.lowerBound - distance
               return (.tooClose, "Move light up \(Int(diff))\" to avoid light burn")
           } else if distance > optimal.upperBound {
               let diff = distance - optimal.upperBound
               return (.tooFar, "Move light down \(Int(diff))\" for better growth")
           } else {
               return (.optimal, "Perfect distance! ðŸŽ¯")
           }
       }

       static func optimalRange(for lightType: LightType, stage: GrowthStage) -> ClosedRange<Double> {
           switch (lightType, stage) {
           case (.led, .seedling): return 24...30
           case (.led, .vegetative): return 18...24
           case (.led, .flowering): return 12...18
           case (.hps, .seedling): return 30...36
           case (.hps, .vegetative): return 24...30
           case (.hps, .flowering): return 18...24
           case (.cfl, _): return 6...12
           case (.cmh, .seedling): return 30...36
           case (.cmh, .vegetative): return 24...30
           case (.cmh, .flowering): return 18...24
           default: return 18...24 // Default
           }
       }
   }
   ```

5. **Tutorial Overlay:**
   ```swift
   struct LightDistanceTutorial: View {
       @Binding var isPresented: Bool

       var body: some View {
           ZStack {
               Color.black.opacity(0.7)
                   .ignoresSafeArea()

               VStack(spacing: 32) {
                   TutorialStep(
                       number: 1,
                       icon: "lightbulb.fill",
                       title: "Tap Your Light",
                       description: "Point your camera at the light source and tap to mark it"
                   )

                   TutorialStep(
                       number: 2,
                       icon: "leaf.fill",
                       title: "Tap Plant Canopy",
                       description: "Point at the top of your plant and tap to mark it"
                   )

                   TutorialStep(
                       number: 3,
                       icon: "ruler",
                       title: "Get Distance",
                       description: "See the distance and recommendation instantly"
                   )

                   NeonButton(
                       title: "Got It!",
                       action: {
                           UserDefaults.standard.set(true, forKey: "hasSeenLightARTutorial")
                           isPresented = false
                       }
                   )
               }
               .padding()
           }
       }
   }
   ```

### Smart Greenhouse Design Integration

**AR Overlay:**
- Neon markers (yellow for light, green for canopy)
- Glassmorphic distance label
- Animated measurement line with glow effect
- Color-coded feedback (green/orange/red)

**Recommendation Card:**
- GlassCard with status-colored border
- Large distance display (monospaced font)
- Icon indicator (checkmark/warning/x)
- Action button: "Save Measurement"

### Device Compatibility

**ARKit Requirements:**
- iOS 11+ for basic AR
- iOS 14+ for improved tracking
- iOS 14+ with LiDAR for low-light accuracy

**Fallback Strategy:**
- ARKit unavailable â†’ manual entry UI
- No LiDAR + low light â†’ suggest turning on flashlight
- Poor tracking â†’ show recalibration guide

### Testing

- Unit tests:
  - Distance calculation accuracy
  - Recommendation logic for all light types/stages
  - Optimal range calculations
- Integration tests:
  - AR session starts successfully
  - Markers placed on tap
  - Distance calculated between markers
  - Measurement saved to plant profile
- Manual checks:
  - Test on device with LiDAR (iPhone 12 Pro+)
  - Test on device without LiDAR (iPhone SE, older models)
  - Test in bright and low-light conditions
  - Verify accuracy with physical measuring tape
  - Test tutorial flow for first-time users
  - Test manual entry fallback

### Educational Opportunity

Include in-app tips:
- "Too close can cause light burn (bleaching)"
- "Too far reduces growth rate"
- "Adjust distance as plant grows"
- "Different light types have different optimal distances"

## Change Log

| Date       | Version | Description                      | Author |
|-----------|---------|----------------------------------|--------|
| 2025-11-15 | 1.0     | Initial story creation           | Mary (BA) |

## Dev Agent Record

*Awaiting implementation*
